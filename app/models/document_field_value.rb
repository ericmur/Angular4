class DocumentFieldValue < ActiveRecord::Base
  DATE_FORMAT = "%m/%d/%Y"
  belongs_to :document

  attr_accessor :input_value
  attr_accessor :user_id #The logged in user who is going to encrypt this field value. See encrypt_value method. Could be Head-of-Household who has permissions to upload documents for a user or the user himself (i.e. group_user.user)

  before_save :encrypt_value
  after_save  :clear_input_value

  validates :local_standard_document_field_id, presence: true #This field is used as the association id with standard_document_field model. This field is an id that is only unique in standard_document_fields table in scope of standard_document. We have not used belongs_to/has_many relationship between DocumentField and DocumentFieldValue because it is cumbersome to maintain the same ids as generated by Database for DocumentField across StandardBaseDocument.load call. So we use our own id: StandardDocumentField#field_id

  validates :local_standard_document_field_id, :uniqueness => { :scope => :document_id }
  validates :encrypt_value, :presence => true #If value is nil then that record should be deleted

  def base_standard_document_field
    BaseDocumentField.where(:field_id => self.local_standard_document_field_id, :standard_document_id => self.document.standard_document_id).first or BaseDocumentField.where(:field_id => self.local_standard_document_field_id, :document_id => self.document_id).first
  end

  def decrypt_value
    return nil if self.encrypted_value.nil?
    symmetric_key = self.document.symmetric_keys.for_user_access(self.user_id).first

    aes = Encryption::Aes.new(:key => symmetric_key.decrypt_key, :iv => symmetric_key.decrypt_iv)
    aes.decrypt(Base64.decode64(self.encrypted_value))
  end

  def field_value
    if base_standard_document_field.encryption?
      decrypt_value
    else
      self.value
    end
  end

  def field_date_value
    return nil if self.base_standard_document_field.notify == false
    self.date_value
  end

  def date_value
    Date.strptime(self.field_value, DATE_FORMAT) if self.field_value
  end

  def process_notify_durations(create_notification=false)
    std_field = self.base_standard_document_field
    return unless BaseDocumentField::ALERT_DATA_TYPES.include?(std_field.data_type)
    return if std_field.notify_durations.count == 0
    return unless std_field.notify?

    date_value = field_date_value
    schedules = std_field.notify_durations.to_a.map{|e| e.scheduled_date = date_value - e.amount.to_i.send(e.unit); e }.sort{|a, b| a <=> b }
    today = Time.zone.today

    self.update_column(:notification_level, NotifyDuration::NONE)
    should_notify = false

    if today >= date_value # expired / due
      self.update_column(:notification_level, NotifyDuration::EXPIRED)
      should_notify = true
    elsif schedules.select{ |e| e.scheduled_date == today }.first
      self.update_column(:notification_level, NotifyDuration::EXPIRING)
      should_notify = true
    end

    if create_notification && should_notify
      notify_duration = schedules.select{ |e| e.scheduled_date == date_value }.first
    end

    if create_notification && should_notify && (notify_duration || today == date_value)
      if std_field.data_type == 'due_date'
        send_due_document_notification(notify_duration: notify_duration)
      else
        send_expiring_document_notification(notify_duration: notify_duration)
      end
    end

    self.notification_level
  end

  def should_skip_due_notification?
    document_paid?
  end

  def document_paid?
    document.document_field_values.all.select do |v|
      v.base_standard_document_field.name == BaseDocumentField::PAID_FIELD_NAME && v.value == "true"
    end.first.present?
  end

  def migrate_value!
    if base_standard_document_field.encryption? && self.encrypted_value.blank? && self.value.present?
      migrate_plain_to_encrypted_value!
    elsif !base_standard_document_field.encryption? && self.encrypted_value.present? && self.value.blank?
      migrate_encrypted_to_plain_value!
    end
  end

  def add_value_as_suggestion(user)
    field = base_standard_document_field
    return unless field
    return if field.encryption?
    return unless field.suggestions
    CalculateFieldValueSuggestionsJob.perform_later(user.id, document.standard_document_id, base_standard_document_field.name, self.value)
  end

  private

  def migrate_plain_to_encrypted_value!
    return if self.value.blank?
    self.input_value = self.value
    self.value = nil
    self.save!
  end

  def migrate_encrypted_to_plain_value!
    self.value = self.decrypt_value
    if self.value.present?
      self.encrypted_value = nil
      self.input_value = self.value
    end
    self.save!
  end

  def send_due_document_notification(options={})
    return if should_skip_due_notification?
    notify_duration = options[:notify_duration]
    message = notification_message_for_due_date(notify_duration)
    send_document_notification_to_owner(notify_duration, message)
  end

  def send_expiring_document_notification(options={})
    notify_duration = options[:notify_duration]
    message = notification_message_for_expiry_date(notify_duration)
    send_document_notification_to_owner(notify_duration, message)
  end

  def send_document_notification_to_owner(notify_duration, message)
    document_owner_ids.each do |owner_user_id|
      notification = Notification.new
      notification.recipient = User.find_by_id(owner_user_id)
      notification.message = message
      notification.notifiable = self.document
      notification.notification_type = Notification.notification_types[:document_expiring]
      if notification.save
        notify_duration_id = notify_duration ? notify_duration.id : nil
        notification.deliver([:push_notification, :email], { field_value_id: self.id, notify_duration_id: notify_duration_id })
      end
    end
  end

  def notification_message_for_expiry_date(notify_duration)
    message = nil
    if self.notification_level == NotifyDuration::EXPIRING
      remaining_duration = [notify_duration.amount.to_i, notify_duration.unit.to_s.singularize.pluralize(notify_duration.amount.to_i)].join(' ')
      formatted_date_value = field_date_value.strftime(DATE_FORMAT)
      message = "#{document.standard_document.name} is about to expire in #{remaining_duration} (#{formatted_date_value})"
    else
      message = "#{document.standard_document.name} has expired"
    end
    message
  end

  def notification_message_for_due_date(notify_duration)
    message = nil
    if self.notification_level == NotifyDuration::EXPIRING
      remaining_duration = [notify_duration.amount.to_i, notify_duration.unit.to_s.singularize.pluralize(notify_duration.amount.to_i)].join(' ')
      formatted_date_value = field_date_value.strftime(DATE_FORMAT)
      if remaining_duration == "1 day"
        message = "#{document.standard_document.name} is due tomorrow"
      else
        message = "#{document.standard_document.name} is due in #{remaining_duration} (#{formatted_date_value})"
      end
    elsif self.notification_level == NotifyDuration::EXPIRED
      message = "#{document.standard_document.name} is due"
    end
    message
  end

  def document_owner_ids
    owners = []
    if self.document.document_owners.where(owner_type: %w[User Consumer]).count == 0
      owners << self.document.uploader_id
    else
      self.document.document_owners.each do |doc_owner|
        if doc_owner.owner.class == GroupUser and doc_owner.owner.user
          owners << doc_owner.owner.user_id
        elsif doc_owner.consumer?
          owners << doc_owner.owner_id
        end
      end
    end
    owners
  end

  def encrypt_value
    unless self.input_value.blank?
      if base_standard_document_field.encryption?
        symmetric_key = self.document.symmetric_keys.for_user_access(self.user_id).first
        aes = Encryption::Aes.new(:key => symmetric_key.decrypt_key, :iv => symmetric_key.decrypt_iv)

        self.value = nil
        self.encrypted_value = Base64.encode64(aes.encrypt(self.input_value))
      else
        self.encrypted_value = nil
        self.value = self.input_value
      end
    else
      self.encrypted_value = nil
      self.value = nil
    end
  end

  def clear_input_value
    self.input_value = nil
  end

  def self.find_with_user_access(object, user)
    doc_field_value = DocumentFieldValue.where(:document_id => object.document_id, :local_standard_document_field_id => object.local_standard_document_field_id).first
    doc_field_value && doc_field_value.document.accessible_by_me?(user) ? doc_field_value : nil
  end
end
