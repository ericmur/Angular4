##### First step is a connection to websocket server:

###### Client request:

```
{
    "channel" => "/meta/handshake",
    "version" => "1.0",
    "supportedConnectionTypes" => [
        "websocket",
        "eventsource",
        "long-polling",
        "cross-origin-long-polling",
        "callback-polling"
    ],
    "id" => "1",
    "data" => {
        "sender_type" => "Advisor",
        "sender_id" => 1,
        "auth_token" => "-Jnc9MbUGijfArYsJFFY"
    }
}
```

###### Server response:

```
{
    "id" => "1",
    "channel" => "/meta/handshake",
    "successful" => true,
    "version" => "1.0",
    "supportedConnectionTypes" => [
        "long-polling",
        "cross-origin-long-polling",
        "callback-polling",
        "websocket",
        "eventsource",
        "in-process"
    ],
    "clientId" => "77iflfy33ovzi8i1mf9zq991hn2jqtq",
    "advice" => {
        "reconnect" => "retry",
        "interval" => 0,
        "timeout" => 100000
    }
}
```

##### Client request

```
{
    "channel" => "/meta/connect",
    "clientId" => "77iflfy33ovzi8i1mf9zq991hn2jqtq",
    "connectionType" => "websocket",
    "id" => "2",
    "data" => {
      "sender_type" => "Advisor",
      "sender_id" => 1,
      "auth_token" => "-Jnc9MbUGijfArYsJFFY"
    }
}
```
*channel* -- this is set by our front-end faye client, this is a service channel that handles connection between client and server.

*clientId* -- this is an Id automaticaly generated by front-end faye client. We don't use it directly, but server internally use it to distinguish between different clients.

*id* -- Id of message. This is automaticaly generated by fayeApp too. Unique id of a message. We don't use it too, but it is used by Faye.

*version* - version of a Bayeux protocol, that is used by Faye.

*supportedConnectionTypes* - an array with supported connection types by server. Client can choose from any of them by including one in a message under ‘ConnectionType’ field.

*advice* - server advice for default behavior of client. Can set connection timeout and retry timeout. Client can ignore this.

*connectionType* -- this is a desired connection type for a client.

*data* block -- we store here all the data that we need ( payload ). More details in a 'send message step' a bit later.
___
#### Second step is a subscription:

##### Client: 

```
{
    "channel" => "/meta/subscribe",
    "clientId" => "77iflfy33ovzi8i1mf9zq991hn2jqtq",
    "subscription" => "/chats/1",
    "id" => "3",
    "data" => {
        "sender_type" => "Advisor",
        "sender_id" => 1,
        "auth_token" => "-Jnc9MbUGijfArYsJFFY"
    }
}
```

##### Server:

( successful subscription with valid auth_token )
```
{
    "id" => "3",
    "clientId" => "77iflfy33ovzi8i1mf9zq991hn2jqtq",
    "channel" => "/meta/subscribe",
    "successful" => true,
    "subscription" => "/chats/1"
}
```
( failed subscription with invalid auth_token )
```
{
    "id" => "3", 
    "clientId" => "77iflfy33ovzi8i1mf9zq991hn2jqtq",
    "channel" => "/meta/subscribe",
    "error" => "403::Forbidden",
    "successful" => false,
    "subscription" => "/chats/1"
}
```
When client tries to subscribe to a channel (in our case it a 'chat' channel), Faye attempts to authenticate user by getting *sender_type*, *sender_id*, *auth_token* and parsing *subscription* field to get chat_id.
Authentication for Advisor and Consumer is different - Advisor need to provide their authentication_token for *auth_token* field, while Consumer should use it's oauth_access_key.
If authentication is failed ( user auth_token invalid or user doesn't exist or doesn't belong to chat ), Faye will return *successful* => false and set an *error* field with error message. In this case, Client won't be able to receive messages from this chat.

Note:
On BackboneApp we use Extension for FayeClient that automaticaly sets *sender_id*, *sender_type*, *auth_token* to every outgoing Faye request.

*channel* - '/meta/subscribe' is a service channel used for subscribing to channels

*subscription* - contains channel to subscribe to.

###### *data*

*sender_type*  - sender user type, can be "Advisor" or "Consumer". Method of authentication will be chosen based on this field.

*sender_id* - sender user id in a DocytApp db.

*auth_token* - *authentication_token* for Advisor or *oauth_access_token* for Consumer
___
#### Third step is publishing

###### From Advisor to Client:

```
{
    "channel" => "/chats/1",
    "data" => {
        "text" => "Example message text",
        "type" => "sms",
        "sender_type" => "Advisor",
        "sender_id" => 1,
        "auth_token" => "-Jnc9MbUGijfArYsJFFY"
    }, "clientId" => "bbeqq4ev0lmuumgbugbxo4rvsdg94q6",
    "id" => "5"
}
```

###### From Consumer To Advisor:

```
{
    "channel" => "/chats/1",
    "data" => {
        "text" => "Example message text",
        "type" => "web",
        "sender_type" => "Consumer",
        "sender_id" => 1,
        "auth_token" => "-KiTUyYtyWdTQLRY6iD-C"
    }, "clientId" => "bbeqq4ev0lmuumgbugbxo4rvsdg94q6",
    "id" => "5"
}
```

###### Server:
( successfuly sent message with valid params )

```
{
    "id" => "5",
    "clientId" => "bbeqq4ev0lmuumgbugbxo4rvsdg94q6",
    "channel" => "/chats/1",
    "successful" => true
}
```

( failed to send message with invalid params )

```
{
    "id" => "5",
    "clientId" => "bbeqq4ev0lmuumgbugbxo4rvsdg94q6",
    "channel" => "/chats/1",
    "error" => "["Text can't be blank"]",
    "successful" => false
}
```

In case of invalid message params, FayeApp will return *successful => false* and *error* field with an array of errors. 

*type* - can be of following type: 'web', 'sms', 'email'. The last two types can only be used if receiver is 'Client' and it is not-connected ( have no Consumer ).
